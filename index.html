<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>論文テキスト整形ツール（セクション空行対応）</title>
<style>
  :root{
    --bg:#f7f8fa;
    --card:#fff;
    --accent:#0078D7;
    --muted:#666;
  }
  body{
    font-family: "Segoe UI", "Hiragino Sans", "Yu Gothic", sans-serif;
    margin: 24px;
    background:var(--bg);
    color:#222;
  }
  h1{
    text-align:center;
    margin-bottom:18px;
  }

  .container{
    max-width:1200px;
    margin:0 auto;
  }

  .cols{
    display:flex;
    gap:20px;
    align-items:flex-start;
    justify-content:center;
    flex-wrap:wrap;
  }

  .col{
    flex:1;
    min-width:420px;
    display:flex;
    flex-direction:column;
  }

  label{
    font-weight:600;
    margin-bottom:8px;
    color:var(--muted);
  }

  textarea{
    width:100%;
    height:68vh; /* 縦長に */
    min-height:520px;
    padding:14px;
    border-radius:10px;
    border:1px solid #d7dbe0;
    background:var(--card);
    resize:vertical;
    font-size:15px;
    line-height:1.7;
    box-shadow:0 3px 10px rgba(15,20,30,0.03);
  }

  .controls{
    display:flex;
    gap:8px;
    justify-content:center;
    margin-top:14px;
    flex-wrap:wrap;
  }

  button{
    padding:10px 16px;
    border-radius:8px;
    border:none;
    background:var(--accent);
    color:white;
    cursor:pointer;
    font-size:14px;
  }

  button.secondary{
    background:#4CAF50;
  }

  @media (max-width:900px){
    .cols{ flex-direction:column; }
    textarea{ height:40vh; min-height:240px; }
  }

  /* 出力の見やすさ向上 */
  #output { white-space:pre-wrap; word-break:break-word; }
</style>
</head>
<body>
  <div class="container">
    <h1>論文テキスト整形ツール（セクション空行対応）</h1>

    <div class="cols">
      <div class="col">
        <label for="input">▼ 原文（整形前）</label>
        <textarea id="input" placeholder="ここに論文テキストを貼り付けてください..."></textarea>
      </div>

      <div class="col">
        <label for="output">▼ 整形後（Google翻訳向け）</label>
        <textarea id="output" readonly placeholder="整形結果がここに表示されます..."></textarea>
      </div>
    </div>

    <div class="controls" style="margin-top:18px;">
      <button id="copyBtn" class="secondary">整形結果をコピー</button>
      <button id="clearBtn" style="background:#e0e0e0;color:#111;">入力をクリア</button>
    </div>
  </div>

<script>
/*
整形ルール（要点）
- 列幅による途中改行を潰して、段落を1行の連続テキストにする。
- Section番号（整数のみ: "5 Title"）の前に改行を3つ挿入（空行3行）。
- Sub-section番号（小数を含む: "5.1 Title" や "12.3 Title"）の前に改行を2つ挿入（空行2行）。
- "et al." は "et al." (NBSP) に変換して分割されないようにする。
- "Self-Evolution." のような長めの単語＋ピリオドは特別に
    - 前に空行1行追加して、その単語を独立させる
- 文末で改行する（一文ごとに切る）処理は行わない（無効）
*/

const inputEl = document.getElementById('input');
const outputEl = document.getElementById('output');
const copyBtn = document.getElementById('copyBtn');
const clearBtn = document.getElementById('clearBtn');

function formatText(raw){
  if(!raw || !raw.trim()) return '';

  // 1) normalize line endings
  let s = raw.replace(/\r/g, '');

  // 2) split into lines, trim each, remove pure-empty lines
  let lines = s.split(/\n/).map(l => l.trim()).filter(l => l.length > 0);

  // 3) join into single line (collapse column wrap)
  s = lines.join(' ');

  // 4) protect common phrases that must not be split
  s = s.replace(/\bet\s+al\./gi, 'et\u00A0al.');

  // 5) Section / Sub-section spacing
  //    5, 12, 5.1, 12.3 などを判定して改行
  s = s.replace(/\b(\d+(?:\.\d+)*)\s+([A-Z])/g, (m, num, nextChar) => {
    const isSub = num.includes('.');
    if(isSub){
      // sub-section: 2行前に空行1行
      return '\n\n' + num + ' ' + nextChar;
    } else {
      // section: 3行前に空行2行
      return '\n\n\n' + num + ' ' + nextChar;
    }
  });

  // 6) Special-case: title-like words (Self-Evolution.) not immediately after section/sub-section
  s = s.replace(
    /(^|\n)(?!\d+(\.\d+)*\s)([A-Z][A-Za-z\-]{2,}(?:-[A-Z][A-Za-z\-]{2,})*[.:])/g,
    (match, p1, p2, word) => {
      // 文頭か改行直後、かつ section/sub-section 直後でなければ改行
      return p1 + '\n' + word + '\n';
    }
  );

  // 7) cleanup: collapse multiple spaces and limit consecutive newlines
  s = s.replace(/[ \t]{2,}/g, ' ');
  s = s.replace(/\n{4,}/g, '\n\n\n');

  // 8) trim
  s = s.replace(/^\s+/, '');
  s = s.replace(/\s+$/, '');

  return s;
}

// Debounced real-time formatting
let tmr = null;
function scheduleFormat(){
  if(tmr) clearTimeout(tmr);
  tmr = setTimeout(() => {
    outputEl.value = formatText(inputEl.value);
  }, 120);
}


// Events
inputEl.addEventListener('input', scheduleFormat);
inputEl.addEventListener('paste', () => {
  // after paste, schedule
  setTimeout(scheduleFormat, 50);
});

// copy
copyBtn.addEventListener('click', () => {
  if(!outputEl.value){
    alert('整形結果が空です。入力を確認してください。');
    return;
  }
  outputEl.select();
  try{
    document.execCommand('copy');
    //alert('整形済みテキストをコピーしました。');
  } catch(e){
    alert('コピーに失敗しました。ブラウザによっては許可が必要です。');
  }
});

// clear
clearBtn.addEventListener('click', () => {
  if(confirm('入力欄をクリアしますか？')){
    inputEl.value = '';
    outputEl.value = '';
  }
});

// 初期サンプル（あればテスト用に自動で整形して表示したい場合はここを編集）
/*
inputEl.value = `5 LLM-Generated Annotations
Utilization
LLM-generated annotations provide a valuable resource
of labeled data for NLP models in different
stages. Hereby we explore the methods for utilizing
and learning with LLM-Generated Annotations.
5.1 Supervised Fine-Tuning
Supervised fine-tuning can effectively enhance
models’ specific capabilities or knowledge. In this
section, we discuss the utilization of generated annotation
for supervised fine-tuning.
Self-Evolution. Huang et al. (2023) first propose
the concept of self-improve that utilizes LLMs as
both data annotators and learnable models and iteratively`;
scheduleFormat();
*/

</script>
</body>
</html>
